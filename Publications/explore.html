---
layout: page
title: Explore Topics
---

<div id="explore">
  <div id="graph">
    <button id="fitBtn" class="fit-btn" title="Fit to view">Fit</button>
  </div>
  <div id="details">
    <h3>Click a topic to see papers</h3>
    <p>You can also link here with <code>?tag=CFD</code> (or any topic).</p>
  </div>
</div>

<style>
#explore { display: grid; grid-template-rows: auto auto; gap: 16px; }
#graph {
  position: relative; height: 520px; border: 1px solid #eee; border-radius: 8px;
  background: rgba(0,0,0,0.02); overflow: hidden;
}
.fit-btn{
  position: absolute; right: 8px; top: 8px; z-index: 2;
  font-size: 12px; padding: 4px 8px; border-radius: 6px;
  border: 1px solid rgba(0,0,0,.15); background: #fff; cursor: pointer;
}
.fit-btn:hover{ filter: brightness(0.97); }

#details { padding: 8px 12px; border: 1px solid #eee; border-radius: 8px; }
#details ul { margin: 0; padding-left: 18px; }

/* Links & nodes */
.link { stroke: #000; stroke-opacity: .3; }
.node { cursor: pointer; }
.node circle { transition: r 120ms ease, opacity 120ms ease; }

/* Label halo for readability */
.node text.label{
  paint-order: stroke fill;
  stroke: rgba(255,255,255,0.95);
  stroke-width: 3px;
  letter-spacing: 0.2px;
  user-select: none;
  pointer-events: none;
  fill: currentColor;
}

.legend { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
.badge { display:inline-block; padding:3px 6px; border-radius:6px; font-size:12px; border:1px solid rgba(0,0,0,.1); }

@media (prefers-color-scheme: dark){
  #graph  { background: rgba(255,255,255,0.03); border-color: rgba(255,255,255,.12); }
  #details{ border-color: rgba(255,255,255,.12); }
}
@media (max-width: 900px){ #graph { height: 58vh; } }
</style>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

<script>
(function(){
  // ----- TUNING KNOBS -----
  var TOP_K_ALWAYS = 12;          // always show these many top labels
  var ZOOM_LABEL_THRESHOLD = 1.6; // show more labels when zoomed in beyond this
  var LABEL_PADDING = 2;          // px padding for overlap test
  // -------------------------

  var GRAPH_URL = "{{ '/assets/data/topic_graph.json' | relative_url }}";
  var PUBS_URL  = "{{ '/assets/data/pubs.json' | relative_url }}";

  var graphEl   = document.getElementById('graph');
  var detailsEl = document.getElementById('details');
  var fitBtn    = document.getElementById('fitBtn');
  var qs        = new URLSearchParams(location.search);
  var startTag  = qs.get('tag');

  // --- Preferred casing for labels based on BibTeX keywords in pubs.json ---
  function buildCaseMap(pubs){
    // Map: lowercased tag -> Map(variantString -> count)
    var raw = new Map();
    pubs.forEach(function(p){
      (p.tags || []).forEach(function(t){
        var v = String(t).trim();
        if(!v) return;
        var k = v.toLowerCase();
        var m = raw.get(k) || new Map();
        m.set(v, (m.get(v) || 0) + 1);
        raw.set(k, m);
      });
    });
    // Choose best variant per key: highest count; tie-break by uppercase richness, then shorter
    var out = new Map();
    function scoreUpper(s){
      var letters = s.replace(/[^A-Za-z]/g,'');
      if(!letters.length) return 0;
      var upper = (s.match(/[A-Z]/g)||[]).length;
      // small bonus if it's fully upper (acronyms like CFD, LLM)
      return upper/letters.length + (/^[A-Z0-9\-]+$/.test(s) ? 0.5 : 0);
    }
    raw.forEach(function(variants, key){
      var best = null, bestCount = -1, bestScore = -1;
      variants.forEach(function(cnt, variant){
        var sc = scoreUpper(variant);
        if (cnt > bestCount || (cnt === bestCount && (sc > bestScore || (sc === bestScore && variant.length < best.length)))){
          best = variant; bestCount = cnt; bestScore = sc;
        }
      });
      out.set(key, best);
    });
    return out;
  }

  // Fallback: basic title-case that preserves acronyms & separators
  function smartTitleCase(s){
    return String(s).split(/(\s+|[-_/]+)/).map(function(tok){
      if (/^\s+$|^[-_/]+$/.test(tok)) return tok;            // keep separators
      if (/^[A-Z0-9]{2,}$/.test(tok)) return tok;            // keep acronyms (CFD, LLM)
      return tok.charAt(0).toUpperCase() + tok.slice(1);
    }).join('');
  }


  function renderDetails(topic, pubs){
    if(!topic){
      detailsEl.innerHTML = '<h3>Click a topic to see papers</h3><p>You can also link here with <code>?tag=CFD</code> (or any topic).</p>';
      return;
    }
    var filtered = pubs.filter(function(p){
      var tags = (p.tags || []).map(function(t){ return String(t).toLowerCase(); });
      return tags.indexOf(String(topic).toLowerCase()) >= 0;
    });

    var byYear = {};
    filtered.forEach(function(p){
      var y = p.year || '—';
      (byYear[y] = byYear[y] || []).push(p);
    });
    var years = Object.keys(byYear).sort(function(a,b){
      if(b === '—') return -1;
      return (+b) - (+a);
    });

    var html = '<h3>'+topic+'</h3><div class="legend"><span class="badge">Papers: '+filtered.length+'</span></div><ul>';
    years.forEach(function(y){
      byYear[y].sort(function(a,b){ return a.title.localeCompare(b.title); });
      byYear[y].forEach(function(p){
        var venue = p.venue ? ', <em>'+p.venue+'</em>' : '';
        var yearTxt = p.year ? ', '+p.year : '';
        var link = p.url ? ' <a href="'+p.url+'" target="_blank" rel="noopener">[Link]</a>' : '';
        html += '<li>'+p.title+venue+yearTxt+link+'</li>';
      });
    });
    html += '</ul>';
    detailsEl.innerHTML = html;
  }

  function drawGraph(data, pubs){
    if(!data || !data.nodes || data.nodes.length === 0){
      graphEl.innerHTML = '<div style="padding:12px;">No topics found. Ensure BibTeX <code>keywords</code> are present so tags can be generated.</div>';
      return;
    }

    // Preferred casing for labels (from pubs.json); fallback to title case
    var caseMap = buildCaseMap(pubs);
    function displayLabel(id){
      var k = String(id).toLowerCase();
      return caseMap.get(k) || smartTitleCase(id);
    }

    
    var rect   = graphEl.getBoundingClientRect();
    var width  = rect.width || 800;
    var height = rect.height || 520;

    var svg = d3.select(graphEl).append('svg')
      .attr('width', width)
      .attr('height', height);

    var g = svg.append('g').attr('class', 'viz');

    // ---------- helpers ----------
    // paper counts per tag (for node size)
    var topicCount = new Map();
    pubs.forEach(function(p){
      (p.tags || []).forEach(function(t){
        var key = String(t).toLowerCase();
        topicCount.set(key, (topicCount.get(key) || 0) + 1);
      });
    });
    function countFor(id){ return topicCount.get(String(id).toLowerCase()) || 1; }

    var counts = Array.from(topicCount.values());
    var cExtent = (counts.length ? d3.extent(counts) : [1,1]);
    var rScale  = (cExtent[0] === cExtent[1])
      ? function(){ return 10; }
      : d3.scaleSqrt().domain(cExtent).range([20, 50]);
    function nodeR(d){ return rScale(countFor(d.id)); }
    function ringWidth(d){ return d3.scaleLinear().domain([8,22]).range([0.8, 3])(nodeR(d)); }

    // weighted degree (also used for fallback color and label priority)
    var degree = new Map();
    data.nodes.forEach(function(n){ degree.set(n.id, 0); });
    data.links.forEach(function(l){
      var w = l.weight || 1;
      var s = (typeof l.source === 'string') ? l.source : (l.source.id || l.source);
      var t = (typeof l.target === 'string') ? l.target : (l.target.id || l.target);
      degree.set(s, (degree.get(s) || 0) + w);
      degree.set(t, (degree.get(t) || 0) + w);
    });

    // community palette (vivid)
    var useCommunity = data.nodes.some(function(n){ return n.community !== undefined; });
    var commCounts = new Map();
    if(useCommunity){
      data.nodes.forEach(function(n){
        var cid = +n.community || 0; commCounts.set(cid, (commCounts.get(cid) || 0) + 1);
      });
    }
    var commIds = useCommunity ? Array.from(commCounts.keys()).sort(function(a,b){
      return (commCounts.get(b) - commCounts.get(a)) || (a - b);
    }) : [0];
    var palette = [
      "#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd",
      "#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf",
      "#3182bd","#e6550d"
    ];
    var commColor = new Map();
    commIds.forEach(function(cid, i){ commColor.set(cid, palette[i % palette.length]); });

    var degVals = Array.from(degree.values());
    var degExtent  = d3.extent(degVals);
    var tScale  = (degExtent[0] === degExtent[1]) ? function(){ return 0.6; }
                 : d3.scaleLinear().domain(degExtent).range([0.1, 1.0]);
    var tealStart = d3.hcl("#CFF3F6"), tealEnd = d3.hcl("#006D6F");
    var teal      = d3.interpolateHcl(tealStart, tealEnd);
    function degreeColor(id){ return teal(tScale(degree.get(id) || 0)); }  // fallback
    function nodeColor(d){ return useCommunity ? (commColor.get(+d.community || 0) || "#888") : degreeColor(d.id); }

    // anchors for communities → cluster islands
    var anchors = new Map();
    (function computeAnchors(){
      var K = commIds.length;
      var cx = width/2, cy = height/2;
      if(!useCommunity || K === 1){
        anchors.set(commIds[0] || 0, [cx, cy]); return;
      }
      var R = Math.min(width, height) * 0.32;
      for(var i=0;i<K;i++){
        var ang = (2*Math.PI*i)/K - Math.PI/2;
        anchors.set(commIds[i], [cx + R*Math.cos(ang), cy + R*Math.sin(ang)]);
      }
    })();

    // ---------- forces ----------
    var sim = d3.forceSimulation(data.nodes)
      .force('link', d3.forceLink(data.links)
          .id(function(d){ return d.id; })
          .distance(function(d){
            var w = Math.max(1, d.weight || 1);
            return 90 / Math.sqrt(w);
          })
          .strength(0.30)
      )
      .force('charge', d3.forceManyBody().strength(-200))
      .force('center', d3.forceCenter(width/2, height/2))
      .force('collision', d3.forceCollide().radius(function(d){ return nodeR(d) + 4; }));
    if(useCommunity && commIds.length > 1){
      sim.force('commX', d3.forceX(function(d){ return anchors.get(+d.community || 0)[0]; }).strength(0.08));
      sim.force('commY', d3.forceY(function(d){ return anchors.get(+d.community || 0)[1]; }).strength(0.08));
      sim.force('x', d3.forceX(width/2).strength(0.02));
      sim.force('y', d3.forceY(height/2).strength(0.02));
    } else {
      sim.force('x', d3.forceX(width/2).strength(0.05));
      sim.force('y', d3.forceY(height/2).strength(0.05));
    }

    // ---------- draw ----------
    var link = g.append('g')
      .attr('stroke-linecap','round')
      .selectAll('line')
      .data(data.links)
      .enter().append('line')
      .attr('class','link')
      .attr('stroke-width', function(d){ return d3.scaleLinear()
        .domain(d3.extent(data.links, function(x){ return x.weight || 1; }))
        .range([1.0, 4.0])(d.weight || 1);
      });

    var node = g.append('g')
      .selectAll('g')
      .data(data.nodes)
      .enter().append('g')
      .attr('class','node')
      .call(d3.drag()
        .on('start', dragstarted)
        .on('drag', dragged)
        .on('end', dragended)
      );

    node.append('circle')
      .attr('r', function(d){ return nodeR(d); })
      .attr('fill', '#fff')
      .attr('stroke', function(d){ return nodeColor(d); })
      .attr('stroke-width', function(d){ return ringWidth(d); })
      .on('mouseenter', function(event, d){ highlight(d); })
      .on('mouseleave', function(){ clearHighlight(); })
      .on('dblclick', function(event, d){ d.fx = null; d.fy = null; });
    node.on('click', function(event, d){ selectTopic(d.id); });

    function fontSizeFor(d){
      var fs = nodeR(d) * 0.95;
      return Math.max(11, Math.min(26, fs));
    }
    node.append('text')
      .attr('class','label')
      .text(function(d){ return displayLabel(d.id); })
      .attr('dominant-baseline','middle')
      .attr('text-anchor', function(d){ return (nodeR(d) >= 16) ? 'middle' : 'start'; })
      .attr('x', function(d){ return (nodeR(d) >= 16) ? 0 : (nodeR(d) + 6); })
      .attr('y', 0)
      .attr('font-size', function(d){ return fontSizeFor(d); });

    sim.on('tick', function(){
      link
        .attr('x1', function(d){ return d.source.x; })
        .attr('y1', function(d){ return d.source.y; })
        .attr('x2', function(d){ return d.target.x; })
        .attr('y2', function(d){ return d.target.y; });
      node.attr('transform', function(d){ return 'translate('+d.x+','+d.y+')'; });
    });

    // ---------- interactions & label policy ----------
    var currentTransform = d3.zoomIdentity;
    var visibleSet = new Set(); // ids of labels currently allowed to show
    var zoomTimer = null;

    var zoom = d3.zoom().scaleExtent([0.5, 6]).on('zoom', function(event){
      currentTransform = event.transform;
      g.attr('transform', event.transform);
      // debounce the expensive overlap pass
      if(zoomTimer) clearTimeout(zoomTimer);
      zoomTimer = setTimeout(updateLabelCull, 60);
    }).on('end', function(){
      updateLabelCull();
    });
    svg.call(zoom);

    function fit(){
      var n = g.node();
      if(!n || !n.getBBox) return;
      var bbox = n.getBBox();
      var dx = bbox.width, dy = bbox.height;
      if(!dx || !dy) return;
      var cx = bbox.x + dx/2, cy = bbox.y + dy/2;
      var scale = 0.88 / Math.max(dx / width, dy / height);
      var translate = [width/2 - scale*cx, height/2 - scale*cy];
      svg.transition().duration(500)
        .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
      // ensure culling re-runs after the transition
      setTimeout(updateLabelCull, 550);
    }

    // Priority score for labels (0..1): blend count & degree
    var countsById = new Map();
    data.nodes.forEach(function(n){
      var low = String(n.id).toLowerCase();
      var c = (n.count != null ? +n.count : countFor(n.id));
      countsById.set(n.id, Math.max(0, c));
    });
    function minmax(vals){
      if(!vals.length) return [0,1];
      var lo = Math.min.apply(null, vals), hi = Math.max.apply(null, vals);
      return (lo===hi) ? [lo, lo+1] : [lo, hi];
    }
    var cc = Array.from(countsById.values());
    var dd = Array.from(degree.values());
    var cmm = minmax(cc), dmm = minmax(dd);

    function norm(v, lo, hi){
      return (hi===lo) ? 0.5 : ( (v - lo) / (hi - lo) );
    }
    function scoreFor(n){
      var c = countsById.get(n.id) || 0;
      var d = degree.get(n.id) || 0;
      return 0.6 * norm(c, cmm[0], cmm[1]) + 0.4 * norm(d, dmm[0], dmm[1]);
    }

    // Culling pass: show top-K always; show more past zoom threshold; avoid overlaps
    function updateLabelCull(){
      var labels = node.select('text.label').nodes(); // array of <text>
      // Build list with priority score
      var items = labels.map(function(el){
        var sel = d3.select(el), d = sel.datum();
        return { el: el, d: d, score: scoreFor(d) };
      });
      // Sort by priority desc
      items.sort(function(a,b){ return b.score - a.score; });

      var k = currentTransform.k || 1;
      var always = items.slice(0, TOP_K_ALWAYS);
      var rest   = (k >= ZOOM_LABEL_THRESHOLD) ? items.slice(TOP_K_ALWAYS) : []; // only when zoomed in

      var accepted = [];
      function overlaps(r1, r2){
        return !(r2.left > r1.right - LABEL_PADDING ||
                 r2.right < r1.left + LABEL_PADDING ||
                 r2.top > r1.bottom - LABEL_PADDING ||
                 r2.bottom < r1.top + LABEL_PADDING);
      }
      function tryAccept(item){
        var rect = item.el.getBoundingClientRect();
        for(var i=0;i<accepted.length;i++){
          if(overlaps(accepted[i].rect, rect)) return false;
        }
        accepted.push({ id: item.d.id, rect: rect, el: item.el });
        return true;
      }

      // First, always-on (accept regardless; but still occupy space so others avoid them)
      visibleSet = new Set();
      always.forEach(function(it){
        tryAccept(it);
        visibleSet.add(it.d.id);
      });

      // Then, the rest (respecting overlaps)
      rest.forEach(function(it){
        if(tryAccept(it)) visibleSet.add(it.d.id);
      });

      // Apply visibility
      node.selectAll('text.label')
        .style('opacity', function(nd){ return visibleSet.has(nd.id) ? 1 : 0; });
    }

    // Hover highlight respects culled set but may surface hidden labels temporarily
    function highlight(d){
      var ns = neighbors.get(d.id) || new Set();
      node.selectAll('circle')
        .attr('opacity', function(nd){ return (nd.id === d.id || ns.has(nd.id)) ? 1 : 0.25; });
      link.attr('opacity', function(l){
        var s = (typeof l.source === 'object') ? l.source.id : l.source;
        var t = (typeof l.target === 'object') ? l.target.id : l.target;
        return (s === d.id || t === d.id || ns.has(s) || ns.has(t)) ? 0.9 : 0.12;
      });
      node.selectAll('text.label')
        .style('opacity', function(nd){
          return (nd.id === d.id || ns.has(nd.id) || visibleSet.has(nd.id)) ? 1 : 0.25;
        });
    }
    function clearHighlight(){
      node.selectAll('circle').attr('opacity', 1);
      link.attr('opacity', 0.14);
      node.selectAll('text.label')
        .style('opacity', function(nd){ return visibleSet.has(nd.id) ? 1 : 0; });
    }

    function selectTopic(topic){
      renderDetails(displayLabel(topic), pubs);
      node.selectAll('circle').attr('stroke-width', function(nd){
        return (nd.id === topic) ? Math.max(6, ringWidth(nd) + 2) : ringWidth(nd);
      });
      var url = new URL(location);
      url.searchParams.set('tag', topic);
      history.replaceState(null, '', url);
    }

    // neighbor map for hover highlight
    var neighbors = new Map();
    data.links.forEach(function(l){
      var s = (typeof l.source === 'string') ? l.source : (l.source.id || l.source);
      var t = (typeof l.target === 'string') ? l.target : (l.target.id || l.target);
      if(!neighbors.get(s)) neighbors.set(s, new Set());
      if(!neighbors.get(t)) neighbors.set(t, new Set());
      neighbors.get(s).add(t);
      neighbors.get(t).add(s);
    });

    function dragstarted(event, d){
      if(!event.active) sim.alphaTarget(0.3).restart();
      d.fx = d.x; d.fy = d.y;
    }
    function dragged(event, d){ d.fx = event.x; d.fy = event.y; }
    function dragended(event, d){
      if(!event.active) sim.alphaTarget(0);
    }

    sim.on('end', function(){ fit(); setTimeout(updateLabelCull, 600); });

    if ('ResizeObserver' in window) {
      var ro = new ResizeObserver(function(){
        var r = graphEl.getBoundingClientRect();
        svg.attr('width', r.width || width).attr('height', r.height || height);
        setTimeout(updateLabelCull, 50);
      });
      ro.observe(graphEl);
    }

    fitBtn.addEventListener('click', function(){ fit(); });

    if(startTag){
      var datum = data.nodes.find(function(n){ return n.id.toLowerCase() === String(startTag).toLowerCase(); });
      if(datum){ selectTopic(datum.id); }
    }
  }

  // Load data & render
  Promise.all([fetch(GRAPH_URL), fetch(PUBS_URL)])
    .then(function(results){
      var gRes = results[0], pRes = results[1];
      if(!gRes.ok || !pRes.ok) throw new Error('JSON fetch failed');
      return Promise.all([gRes.json(), pRes.json()]);
    })
    .then(function(payloads){
      drawGraph(payloads[0], payloads[1]);
    })
    .catch(function(err){
      console.error(err);
      graphEl.innerHTML = '<div style="padding:12px;color:#b00020">Could not load data. Make sure Actions generated <code>assets/data/topic_graph.json</code> and <code>assets/data/pubs.json</code>.</div>';
    });
})();
</script>
